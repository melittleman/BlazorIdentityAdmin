@page "/Account/Login"

@using UAParser
@using Device = BlazorAdminDashboard.Domain.Identity.Device;

@inject UserManager<User> UserManager
@inject SignInManager<User> SignInManager
@inject ILogger<Login> Logger
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager

<PageTitle>Log in</PageTitle>

<h1>Log in</h1>
<div class="row">
    <div class="col-md-4">
        <section>
            <StatusMessage Message="@errorMessage" />
            <EditForm Model="Input" method="post" OnValidSubmit="LoginUser" FormName="login" Enhance="true">

                <GeolocationProvider />
                <DataAnnotationsValidator />

                <h2>Use a local account to log in.</h2>
                <hr />

                <ValidationSummary class="text-danger" role="alert" />                

                <div class="form-floating mb-3">
                    <InputText @bind-Value="Input.Email" class="form-control" autocomplete="username" aria-required="true" placeholder="name@example.com" />
                    <label for="email" class="form-label">Email</label>
                    <ValidationMessage For="() => Input.Email" class="text-danger" />
                </div>
                <div class="form-floating mb-3">
                    <InputText type="password" @bind-Value="Input.Password" class="form-control" autocomplete="current-password" aria-required="true" placeholder="password" />
                    <label for="password" class="form-label">Password</label>
                    <ValidationMessage For="() => Input.Password" class="text-danger" />
                </div>
                <div class="checkbox mb-3">
                    <label class="form-label">
                        <InputCheckbox @bind-Value="Input.RememberMe" class="darker-border-checkbox form-check-input" />
                        Remember me
                    </label>
                </div>
                <div>
                    <button type="submit" class="w-100 btn btn-lg btn-primary">Log in</button>
                </div>
                <div>
                    <p>
                        <a href="Account/ForgotPassword">Forgot your password?</a>
                    </p>
                    <p>
                        <a href="@(NavigationManager.GetUriWithQueryParameters("Account/Register", new Dictionary<string, object?> { ["ReturnUrl"] = ReturnUrl }))">Register as a new user</a>
                    </p>
                    <p>
                        <a href="Account/ResendEmailConfirmation">Resend email confirmation</a>
                    </p>
                </div>
            </EditForm>
        </section>

        <MudAlert Severity="Severity.Info" Class="mt-8 mud-width-full" Style="max-width:500px;" Elevation="25">No authentication is required, click sign in.</MudAlert>
    </div>
    <div class="col-md-6 col-md-offset-2">
        <section>
            <h3>Use another service to log in.</h3>
            <hr />
            <ExternalLoginPicker />
        </section>
    </div>
</div>

@code {

    // TODO: I think this is now large enough to be refactored into a 'code behind'.

    private string? errorMessage;

    [CascadingParameter]
    private HttpContext HttpContext { get; set; } = default!;

    [SupplyParameterFromForm]
    private InputModel Input { get; set; } = new();

    // This seems to be the only way we could 'hack' to get 2-way data binding
    // working from an InteractiveServer child component back to a parent SSR one.
    [SupplyParameterFromForm(Name = "GeoLocationProvider.Latitude")]
    private double? Latitude { get; set; } = null;

    [SupplyParameterFromForm(Name = "GeoLocationProvider.Longitude")]
    private double? Longitude { get; set; } = null;

    [SupplyParameterFromQuery]
    private string? ReturnUrl { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (HttpMethods.IsGet(HttpContext.Request.Method))
        {
            // Clear the existing external cookie to ensure a clean login process
            await HttpContext.SignOutAsync(IdentityConstants.ExternalScheme);
        }
    }

    public async Task LoginUser()
    {
        // TODO: We should allow signin with either username or email?
        User? user = await UserManager.FindByNameAsync(Input.Email);
        if (user is null)
        {
            // We can't actually tell the user that it was the 
            // email that was incorrect, otherwise they would be
            // able to figure out what accounts we actually have.
            errorMessage = "Error: Incorrect username or password.";
            return;
        }

        // Will lockout after 5 failed attempts by default...
        SignInResult result = await SignInManager.CheckPasswordSignInAsync(user, Input.Password, lockoutOnFailure: true);
        if (result.Succeeded is false)
        {
            HandleSignInResult(result);
            return;
        }

        DateTimeOffset authTime = DateTimeOffset.UtcNow;
        string? ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString();
        string? userAgent = HttpContext.Request.Headers["User-Agent"];

        if (string.IsNullOrEmpty(userAgent) is false && string.IsNullOrEmpty(ipAddress) is false)
        {
            Parser uaParser = UAParser.Parser.GetDefault();
            ClientInfo clientInfo = uaParser.Parse(userAgent);

            string operatingSystem = clientInfo.OS.ToString();
            string browser = clientInfo.UA.Family;
            string version = $"{clientInfo.UA.Major}.{clientInfo.UA.Minor}.{clientInfo.UA.Patch}";

            // TODO: Think of the right way to separate here if there's a better alternative?
            string deviceName = $"{operatingSystem}:{browser}@{version}";

            string? coordinates = Latitude is not null && Longitude is not null
                ? $"{Latitude}, {Longitude}"
                : null;

            Device device = new()
            {
                Name = deviceName,
                IpAddress = ipAddress,
                Location = coordinates,
                AccessedAt = authTime
            };

            if (SignInManager is CustomSignInManager custom)
            {
                result = await custom.PasswordSignInDeviceAsync(user, device, Input.RememberMe);
            }

            // TODO: Now need to update the user with this new Device if the Signin was successful before we redirect

            HandleSignInResult(result);
        }
    }

    private void HandleSignInResult(SignInResult result)
    {
        if (result.Succeeded)
        {
            Logger.LogInformation("User logged in.");
            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsNotAllowed)
        {
            errorMessage = "Error: Your must confirm your account to login.";
        }
        else if (result.RequiresTwoFactor)
        {
            RedirectManager.RedirectTo(
                "Account/LoginWith2fa",
                new() { ["returnUrl"] = ReturnUrl, ["rememberMe"] = Input.RememberMe });
        }
        else if (result.IsLockedOut)
        {
            Logger.LogWarning("User account locked out.");
            RedirectManager.RedirectTo("Account/Lockout");
        }
        else
        {
            errorMessage = "Error: Invalid login attempt.";
        }
    }

    private sealed class InputModel
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = "";

        [Required]
        [DataType(DataType.Password)]
        public string Password { get; set; } = "";

        [Display(Name = "Remember me?")]
        public bool RememberMe { get; set; }
    }
}
