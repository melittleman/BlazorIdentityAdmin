@page "/"

@inject IPagedTicketStore TicketStore

<PageTitle>Home</PageTitle>

<MudText Typo="Typo.h3" GutterBottom="true">Hello, world!</MudText>
<MudText Class="mb-8">Welcome to your new app, powered by MudBlazor and the .NET 8 Template!</MudText>

@* 
    TODO: It's a shame there doesn't seem to be a better / more efficient way of doing this..
    I just want an 'AuthorizeView' that contains the 'AuthenticationProperties' in @context too.
*@
@if (auth is not null && auth.Succeeded && auth.Principal.Identity?.IsAuthenticated is true)
{
    <h2>Hello @auth.Principal.Identity?.Name, here's the list of your claims:</h2>
    <ul>
        @foreach (var claimGroup in auth.Principal.Claims.GroupBy(a => a.Type))
        {
            foreach (var claimValue in claimGroup.Select(s => s.Value).Distinct())
            {
                <li><b>@claimGroup.Key</b>: @claimValue</li>
            }
        }
    </ul>

    <h3>And here are the properties:</h3>
    <ul>
        @foreach ((string key, string? value) in auth.Properties.Items)
        {
            if (value is null) continue;

            <li><b>@key</b>: @value</li>   
        }
    </ul>
}

@if (tickets is not null)
{
    @* 
        TODO: We can probably explicitely show that this ticket 
        is 'active' because it is available under auth.Ticket.
    *@

    @foreach(AuthenticationTicket ticket in tickets)
    {
        <ul>

            @* TODO: These probably all need moving into extension methods too. *@

            @if (ticket.Properties.Items.ContainsKey("device.os"))
            {
                <li>@ticket.Properties.Items["device.os"]</li>
            }

            @if (ticket.Properties.Items.ContainsKey("device.browser"))
            {
                <li>@ticket.Properties.Items["device.browser"]</li>
            }

            @if (ticket.Properties.Items.ContainsKey("device.location"))
            {
                <li>@ticket.Properties.Items["device.location"]</li>
            }

            @if (ticket.Properties.Items.ContainsKey(".last_activity"))
            {
                <li>@ticket.Properties.Items[".last_activity"]</li>
            }

        </ul>
    }
}

@code {

    private AuthenticateResult? auth;

    [CascadingParameter]
    public required HttpContext HttpContext { get; set; }

    private IPagedList<AuthenticationTicket>? tickets;

    protected override async Task OnInitializedAsync()
    {
        auth = await HttpContext.AuthenticateAsync();

        // string? userId = auth.Principal?.GetClaim(OpenIddictConstants.Claims.Subject);
        // vs.
        string? userId = auth.Principal?.FindFirstValue(OpenIddictConstants.Claims.Subject);
        // Which is better / more efficient?

        if (string.IsNullOrEmpty(userId) is false)
        {
            tickets = await TicketStore.GetByUserIdAsync(userId);
        }

        await base.OnInitializedAsync();
    }
}