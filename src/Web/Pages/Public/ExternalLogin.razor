@page "/external-login"

@inject SignInManager<User> SignInManager
@inject UserManager<User> UserManager
@inject IUserStore<User> UserStore
@inject IEmailSender<User> EmailSender
@inject NavigationManager NavigationManager
@inject IdentityRedirectManager RedirectManager
@inject ILogger<ExternalLogin> Logger
@inject IJSRuntime JS

@attribute [AllowAnonymous]
@rendermode RenderMode.InteractiveServer

<PageTitle>Register</PageTitle>

@if (externalLoginInfo is null)
{
    // TODO: 
    <MudText>Loading...</MudText>
}
else
{
    <MudStack Spacing="4" AlignItems="AlignItems.Center">
        <MudPaper Elevation="4" Class="pa-4" Width="100%">

            <PublicFormHeader>
                <MudText Typo="Typo.h1" GutterBottom="true">Register</MudText>
                <MudText Typo="Typo.subtitle1">Associate your @ProviderDisplayName account.</MudText>
            </PublicFormHeader>

            <StatusMessage Message="@message" />

            @* TODO: We could probably just use the 'StatusMessage' component for this too? But it might need a RenderFragment passing in. *@
            <MudAlert Severity="Severity.Info" Class="mt-8 mud-width-full" Elevation="4">
                You've successfully authenticated with <strong>@ProviderDisplayName</strong>.
                Please confirm or enter an email address below and click the Register button to finish logging in.
            </MudAlert>

            <EditForm Model="Input" FormName="confirmation" id="confirmation-form" method="post" OnValidSubmit="OnValidSubmitAsync">

                @if (HttpContext is null)
                {
                    <input type="hidden" name="_handler" value="confirmation" />
                }

                <DataAnnotationsValidator />

                @* TODO: Need to also add the ability to enter a unique username if not provided. *@

                <MudTextField T="string" @bind-Value="Input.Email"
                    Label="Email"
                    Variant="Variant.Outlined"
                    InputType="InputType.Email"
                    Class="mt-6"
                    autocomplete="email"
                    aria-required="true" />

                <ValidationMessage For="() => Input.Email" class="mud-alert mud-alert-text-error" />

                @* Link for T&C's / Privacy *@
                <MudCheckBox T="bool" @bind-Value="agreeToTerms"
                    Label="I agree to Terms & Conditions" 
                    Color="Color.Primary" 
                    Class="ml-n1 my-3" />

                <MudButton ButtonType="ButtonType.Submit" 
                    Variant="Variant.Filled" 
                    Color="Color.Primary"
                    Disabled="@(!agreeToTerms)" 
                    Size="Size.Large" 
                    FullWidth="true">
                    Register
                </MudButton>
            </EditForm>
        </MudPaper>
    </MudStack>
}

@code {

    private bool agreeToTerms = false;
    public const string LoginCallbackAction = "LoginCallback";

    private string? message;
    private static ExternalLoginInfo? externalLoginInfo;

    private string? ProviderDisplayName => externalLoginInfo?.ProviderDisplayName;

    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    // Static property to persist values through to 
    // SignalR after being set from HttpContext.
    [SupplyParameterFromForm]
    private static ExternalLoginFormInput Input { get; set; } = new();

    [SupplyParameterFromQuery]
    private string? RemoteError { get; set; }

    [SupplyParameterFromQuery(Name = "return_url")]
    private string? ReturnUrl { get; set; }

    [SupplyParameterFromQuery]
    private string? Action { get; set; }

    protected override async Task OnInitializedAsync()
    {
        if (HttpContext is not null)
        {
            if (RemoteError is not null)
            {
                RedirectManager.RedirectToWithStatus("/login", $"Error from external provider: {RemoteError}", HttpContext);
            }

            ExternalLoginInfo? info = await SignInManager.GetExternalLoginInfoAsync();
            if (info is null)
            {
                RedirectManager.RedirectToWithStatus("/login", "Error loading external login information.", HttpContext);
            }

            externalLoginInfo = info;

            if (HttpMethods.IsGet(HttpContext.Request.Method))
            {
                if (Action == LoginCallbackAction)
                {
                    await OnLoginCallbackAsync();
                    return;
                }

                // We should only reach this page via the login callback, so redirect back to
                // the login page if we get here some other way.
                RedirectManager.RedirectTo("/login");
            }
        }

        await base.OnInitializedAsync();
    }

    private async Task OnLoginCallbackAsync()
    {
        // Sign in the user with this external login provider if the user already has a login.
        // TODO: This is going to need to be overwritten to allow us the ability to pass in device info.
        var result = await SignInManager.ExternalLoginSignInAsync(
            externalLoginInfo.LoginProvider,
            externalLoginInfo.ProviderKey,
            isPersistent: false,
            bypassTwoFactor: true);

        if (result.Succeeded)
        {
            Logger.LogInformation(
                "{Name} logged in with {LoginProvider} provider.",
                externalLoginInfo.Principal.Identity?.Name,
                externalLoginInfo.LoginProvider);

            RedirectManager.RedirectTo(ReturnUrl);
        }
        else if (result.IsLockedOut)
        {
            RedirectManager.RedirectTo("/lockout");
        }

        // If the user does not have an account, then ask the user to create an account.
        if (externalLoginInfo.Principal.HasClaim(c => c.Type == OpenIddictConstants.Claims.Email))
        {
            Input.Email = externalLoginInfo.Principal.FindFirstValue(OpenIddictConstants.Claims.Email) ?? "";
        }
    }

    private async Task OnValidSubmitAsync()
    {
        // See: https://github.com/dotnet/aspnetcore/issues/53129
        if (HttpContext is null)
        {
            // TODO
            //isProcessing = true;

            IJSObjectReference loginForm = await JS.InvokeAsync<IJSObjectReference>("document.getElementById", "confirmation-form");
            await loginForm.InvokeVoidAsync("submit");
            return;
        }

        User user = new();

        await UserStore.SetUserNameAsync(user, Input.Email, CancellationToken.None);

        if (UserStore is IUserEmailStore<User> emailStore)
        {
            await emailStore.SetEmailAsync(user, Input.Email, CancellationToken.None);
        }

        // TODO: This is where we need to save the picture, name and preferred username of the external login also.

        IdentityResult result = await UserManager.CreateAsync(user);

        if (result.Succeeded)
        {
            result = await UserManager.AddLoginAsync(user, externalLoginInfo);

            if (result.Succeeded)
            {
                Logger.LogInformation("User created an account using {Name} provider.", externalLoginInfo.LoginProvider);

                string userId = await UserManager.GetUserIdAsync(user);
                string code = await UserManager.GenerateEmailConfirmationTokenAsync(user);

                code = WebEncoders.Base64UrlEncode(Encoding.UTF8.GetBytes(code));

                var callbackUrl = NavigationManager.GetUriWithQueryParameters(
                    NavigationManager.ToAbsoluteUri("/confirm-email").AbsoluteUri,
                    new Dictionary<string, object?> 
                    { 
                        ["userId"] = userId, 
                        ["code"] = code 
                    });

                await EmailSender.SendConfirmationLinkAsync(user, Input.Email, HtmlEncoder.Default.Encode(callbackUrl));

                // If account confirmation is required, we need to show the link if we don't have a real email sender
                if (UserManager.Options.SignIn.RequireConfirmedAccount)
                {
                    RedirectManager.RedirectTo("/register-confirmation", new Dictionary<string, object?>() 
                    { 
                        ["email"] = Input.Email 
                    });
                }

                // TODO: I think this can be safely removed as we don't actually want the registration process
                // to just automatically log the user in, as there is a lot of functionality on the Login page
                // e.g. Device / Geo information and Remember Me that we want the user to pass through.
                //await SignInManager.SignInAsync(user, isPersistent: false, externalLoginInfo.LoginProvider);

                RedirectManager.RedirectTo(ReturnUrl);
            }
        }

        message = $"Error: {string.Join(",", result.Errors.Select(error => error.Description))}";
    }
}
