@implements IDisposable
@inject NavigationManager Navigation
@rendermode RenderMode.InteractiveServer

@if (user is not null)
{
    // We are authenticated.
    // TODO: Need to investigate some more on why <AuthorizeView> doesn't really work for us here.
    // I think it has something to do with the fact that it's a Blazor component that's rendered after the request.

    @* TODO: Add check for Admin role. This could actually be moved into the 'HeaderBar' component also? *@
    <MudIconButton Icon="@Icons.Material.Outlined.Settings" Color="Color.Inherit" Href="/admin" />

    <MudMenu AnchorOrigin="Origin.CenterCenter" Dense="true" Class="mt-1 ml-4">
        <ActivatorContent>

            @if (string.IsNullOrEmpty(AvatarUrl) is false)
            {
                <MudAvatar>
                    <MudImage Src="@AvatarUrl"></MudImage>
                </MudAvatar>
            }
            else
            {
                <MudAvatar>@user.Identity?.Name?.First()</MudAvatar>
            }

        </ActivatorContent>
        <ChildContent>
            <MudCard Elevation="0">
                <MudCardHeader>
                    <CardHeaderAvatar>
                        @if (string.IsNullOrEmpty(AvatarUrl) is false)
                        {
                            <MudAvatar>
                                <MudImage Src="@AvatarUrl"></MudImage>
                            </MudAvatar>
                        }
                        else
                        {
                            <MudAvatar>@user.Identity?.Name?.First()</MudAvatar>
                        }
                    </CardHeaderAvatar>
                    <CardHeaderContent>
                        <MudText Typo="Typo.body2">@user.Identity?.Name</MudText>
                            <MudText Typo="Typo.caption">@user.FindFirstValue(OpenIddictConstants.Claims.Role)</MudText>
                    </CardHeaderContent>
                </MudCardHeader>
            </MudCard>

            <MudDivider Class="mb-4" />

            <MudMenuItem Href="/account/profile" Icon="@Icons.Material.Outlined.Person">Profile</MudMenuItem>
            <MudMenuItem Href="@LogoutUrl" Icon="@Icons.Material.Outlined.Logout">Logout</MudMenuItem>
        </ChildContent>
    </MudMenu>
}
else
{
    <MudButton Href="/register" StartIcon="@Icons.Material.Outlined.AppRegistration" Variant="Variant.Outlined" Class="mr-5">Register</MudButton>
    <MudButton Href="/login" StartIcon="@Icons.Material.Outlined.Login" Variant="Variant.Outlined" Class="mr-5">Login</MudButton>
}

@code {

    // Needs to be static to be persisted from the HTTP Request
    // through to after the SignalR circuit is established.
    private static ClaimsPrincipal? user;
    private string? AvatarUrl => user?.FindFirstValue(OpenIddictConstants.Claims.Picture);

    [CascadingParameter]
    public required HttpContext HttpContext { get; set; }

    private static string? currentUrl;
    private string LogoutUrl => string.IsNullOrEmpty(currentUrl) is false && currentUrl.Contains("logout") is false
        ? "/logout?return_url=" + currentUrl
        : "/logout";

    protected override Task OnInitializedAsync()
    {
        Navigation.LocationChanged += OnLocationChanged;

        // We need a guard here because this method gets called twice, once from the 
        // HTTP Request, and the other from SignalR. So this prevents overwriting.
        if (HttpContext is not null)
        {
            currentUrl = HttpContext.Request.GetEncodedPathAndQuery();

            if (HttpContext.User.Identity?.IsAuthenticated is true)
            {
                user = HttpContext.User;
            }
        }

        return base.OnInitializedAsync();
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        currentUrl = "/" + Navigation.ToBaseRelativePath(e.Location);
        StateHasChanged();
    }

    public void Dispose()
    {
        Navigation.LocationChanged -= OnLocationChanged;
    }
}
