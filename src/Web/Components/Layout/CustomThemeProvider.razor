@rendermode RenderMode.InteractiveServer
@inject IJSRuntime JS

@* Prevents double popovers! *@
<CascadingValue Name="UsePopoverProvider" Value="false">

    <MudThemeProvider @ref="_provider" @bind-IsDarkMode="@_isDarkMode" Theme="_theme" DefaultScrollbar="false" />
</CascadingValue>

@if (_isDarkMode)
{
    <MudTooltip Text="Enable light mode" Color="Color.Tertiary" Placement="Placement.Bottom" Delay="750" Arrow="true">
        <MudIconButton aria-label="Enable light mode" Icon="@Icons.Material.Outlined.LightMode" Color="Color.Inherit" OnClick="ToggleDarkMode" />
    </MudTooltip>
}
else
{
    <MudTooltip Text="Enable dark mode" Color="Color.Tertiary" Placement="Placement.Bottom" Delay="750" Arrow="true">
        <MudIconButton aria-label="Enable dark mode" Icon="@Icons.Material.Outlined.DarkMode" Color="Color.Inherit" OnClick="ToggleDarkMode" />
    </MudTooltip>
}

@code {

    // Note that these need to be static in order to be persisted
    // from the SSR page request through to the SignalR circuit.
    private static MudTheme? _theme;
    private static bool _isDarkMode = true;
    private MudThemeProvider _provider = new();

    private const string DarkModeCookieName = ".isDarkMode";

    [CascadingParameter]
    private HttpContext? HttpContext { get; set; }

    protected override async Task OnInitializedAsync()
    {
        // TODO: Need to either go and load the custom theme parameters from the
        // tenant or introduce a 'fixed' CascadingValue that can be picked up here.
        CustomTheme theme = new();
        bool themeChanged = false;

        if (HttpContext is not null)
        {
            // We are in static SSR mode.
            if (HttpContext.Request.Path.StartsWithSegments("/admin"))
            {
                themeChanged = _theme is MainTheme;
                _theme = new AdminTheme(theme);
            }
            else
            {
                themeChanged = _theme is AdminTheme;
                _theme = new MainTheme(theme);
            }

            if (themeChanged)
            {
                await InvokeAsync(StateHasChanged);
            }

            // We are using Cookies here instead of Local Storage because we would only 
            // be able to retrieve the local storage value AFTER the initial page load.
            if (HttpContext.Request.Cookies.ContainsKey(DarkModeCookieName))
            {
                _isDarkMode = Convert.ToBoolean(HttpContext.Request.Cookies[DarkModeCookieName]);
            }
        }

        await base.OnInitializedAsync();
    }

    private async Task ToggleDarkMode()
    {
        _isDarkMode = !_isDarkMode;

        // name, value, days
        await JS.InvokeVoidAsync("setCookie", DarkModeCookieName, _isDarkMode, 365);
    }
}